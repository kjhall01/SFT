from __future__ import print_function
import sys, os
import json
from pathlib import Path
import platform, copy, warnings
import subprocess
import struct, copy, json
import numpy as np
import datetime as d

import cartopy.crs as ccrs
from cartopy import feature
import cartopy.mpl.ticker as cticker
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.ticker as ticker
from matplotlib.colors import LinearSegmentedColormap
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
import cartopy.feature as cfeature
from cartopy.io.shapereader import Reader
from cartopy.feature import ShapelyFeature
import fileinput
import matplotlib as mpl
from IPython import get_ipython
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
warnings.filterwarnings("ignore")

from .MidpointNormalize import MidpointNormalize	

class Visualizer:
	"""Class for handling all plotting / visualizations
	---------------------------------------------------------------------------
	Variables
		verbose (bool)	: 	whether to print stuff or not
		tgts (list)		:	User-defined list of target seasons "Jun-Aug", "Jun", etc
		inits (list)	:	User-defined list of initialization months "May"
		models (list)	:	User-defined list of model names
		shp_file (Path)	:	a path to a custom shape file
		map_color (str)	:	Either 'CPT', 'Angel', or a pyplot colormap name
		use_topo (Bool)	:	True/False, if plotdomain should use pyplot stock image
		use_default (Bool): True/False if function should use default cartopy shp_files
		fm (FileManager):	FileManager Object for loading data and validating parameters
		use_custom (Bool): 	Whether or not to use a user-supplied shape file
		states_provinces (Cartopy Feature):	A default Cartopy map used for plotting if use_custom = True
	---------------------------------------------------------------------------
	Class Methods (Callable without Instantiation)
	---------------------------------------------------------------------------
	Object Methods
		__init__(tgts, inits, shp_file, map_color, use_topo) -> Visualizer (constructor)
		set_models(models: list) -> None (updates the models variable)
		pltmap(met: str, hindcast_args: [list ArgSet], map_color: str, use_custom: str, use_default:str) -> None (plots metrics for each model for each target season)
		pltdomain(obs_args: ArgSet, hindcast_args: ArgSet) -> None (plots spatial domains in list of provided )
		plteof(MOS, obs_args: [list ArgSet],  map_color: str, use_custom: str, use_default:str) -> None (plots EOF[mode] calculated by CPT)
		plt_probabilistic(model: str, obs_args: ArgSet, MOS:str, shp_file: str, map_color:str, use_custom: str, use_default: str, use_topo:str) -> None ( plots probabilistic forecast generated by Model's CPT run )
		plt_deterministic(model: str, obs_args: ArgSet, MOS:str, shp_file: str, map_color:str, use_custom: str, use_default: str, use_topo:str) -> None ( plots deterministic forecast generated by Model's CPT run )
		read_fcst_switch(fname: str, MOS: str, fcst_type:str, ctlfname:str) -> (lats, lons, data, meta) (calls filemanager.read_forecast if on unix or filemanager.read_forecast_bin if on Windows)
		make_cmap_blue(x: int) -> cmap (creates custom blue colormap used in plt_probabilistic)
		make_cmap(x: int) -> cmap (creates custom colormap based on user specification of map_color variable -> specifically, adds CPT colorscheme)
	---------------------------------------------------------------------------"""
	def __init__(self, fm, shp_file="False", map_color="CPT", use_topo="False", use_default="True", verbose=True):
		self.verbose, self.use_default, self.use_topo = verbose, use_default, use_topo #set variables needed before validation
		if not self.validate_args(shp_file, map_color, str(use_topo), str(use_default)): #if parameters were not allowed
			print('Fix your parameters!')
			return -999
		self.fm = fm #setting more variables
		self.shp_file, self.map_color = shp_file, map_color #setting more variables
		self.use_topo = str(self.use_topo) #setting more variables
		self.use_default = str(self.use_default) #setting more variables
		self.states_provinces = feature.NaturalEarthFeature(category='cultural', name='admin_0_countries',scale='10m',facecolor='none')#setting more variables
		self.models = [] #create a stub #setting more variables
		self.MOSs = {"None": "noMOS", "CCA":"CCA", "PCR":"PCR", "ELR":"ELRho"} #just so we can set mpref, though its only used in filenames now

	def __eq__(self, other):
		ret = True
		for key in vars(self).keys():
			if key not in ['states_provinces', 'shape_feature']:
				if vars(self)[key] != vars(other)[key]:
					ret = False
		return ret

	def  set_models(self, models):
		"""sets internal models variable - validated in the IRIDL constructor"""
		self.models, self.nmods = models, len(models) #setting more variables

	def read_fcst_switch(self, fname, MOS, fcst_type, ctlfname='None'):
		if fname[-4:] == '.dat': #then we are on windows
			return self.fm.read_forecast_bin(fname, MOS,  fcst_type=fcst_type) #so call read-forecast_bin
		else: #then we are on Unix
			return self.fm.read_forecast(fname, MOS, fcst_type=fcst_type, ctlfname=ctlfname) #so call read forecast

	def make_cmap_blue(self,x):
		colors = [(244, 255,255), (187, 252, 255),(160, 235, 255),(123, 210, 255),(89, 179, 238),(63, 136, 254),(52, 86, 254)] #set custom color RGB values
		colors = [ (colors[i][0] / 255.0, colors[i][1] / 255.0, colors[i][2] / 255.0) for i in range(len(colors))] #divide by 255.0 to get fractional values for making colormap
		return LinearSegmentedColormap.from_list( "matlab_clone", colors, N=x)

	def plt_probabilistic(self, model, obs_args, MOS, shp_file="False", map_color=None, use_custom=None, use_default=None, use_topo="False"):
		use_custom = self.use_custom if use_custom is None else use_custom  # allow user to override  use_custom for this funciton
		use_default = self.use_default if use_default is None else use_default  # allow user to override  use_default for this funciton
		if use_custom:
			shp_file = self.shp_file if shp_file=="False" else shp_file # allow user to override  shp_file for this funciton
		map_color = self.map_color if map_color is None else map_color # allow user to override  map_color for this funciton
		if not self.validate_args(shp_file, map_color, use_topo, use_default, models=[model], args=obs_args, MOS='None'): # if args are not alright
			print('Invalid pltmap parameters- fix them!')
			return -999
		self.shp_file, self.map_color = shp_file, map_color # helps with the allowing user override
		self.use_topo = str(self.use_topo) # helps with the allowing user override
		self.use_default = str(self.use_default) # helps with the allowing user override
		if str(use_custom) == "True":
			self.shape_feature = ShapelyFeature(Reader(self.shp_file).geometries(), ccrs.PlateCarree(), facecolor='none')

		x_offset = 0.6 if obs_args[0].obs == 'ENACTS-BD' else 0 #xoffset helps correct ENACTS-BD data weirdness
		y_offset = 0.4 if obs_args[0].obs == 'ENACTS-BD' else 0 #yoffset helps correct ENACTS-BD data weirdness
		self.nsea = len(obs_args) #self.nmods is set in self.set_models - for this its always 1: 'NextGen' is passed as the model

		current_cmap = plt.get_cmap('BrBG') #setting colormaps
		current_cmap.set_under('white', 0.0) #setting colormaps

		current_cmap_copper = plt.get_cmap('YlOrRd', 9) #setting colormaps
		current_cmap_binary = plt.get_cmap('Greens', 4) #setting colormaps
		current_cmap_ylgn = self.make_cmap_blue(9) #setting colormaps

		fig, ax = plt.subplots(nrows=1, ncols=self.nsea, figsize=(13*self.nsea, 10),sharex=True,sharey=True, subplot_kw={'projection': ccrs.PlateCarree()}) #creates pyplot plotgrid with maps

		file_ext = '.dat' if platform.system() == "Windows" else ".txt" #if were on windows, well read a .dat file, if not, read a .txt file (windows doesnt write the .txt files)
		list_probabilistic_by_season = [[[], [], []] for i in range(self.nsea)] #lists of data into which to load data
		for i in range(1):
			for j in range(self.nsea):
				ctlfname = "output/" + model + '_' + obs_args[j].predictand + obs_args[j].predictand +'_' + '{}' + 'FCST_P_' + obs_args[j].target_season.tgt + '_' +obs_args[j].target_season.init+str(obs_args[j].domain.fyr)+file_ext #name of ctl file to read metadata from - file_ext is replaced with .ctl later
				fname = "output/" + model + '_' + obs_args[j].predictand  +'_' + '{}' + 'FCST_P_' + obs_args[j].target_season.tgt + '_' +obs_args[j].target_season.init+str(obs_args[j].domain.fyr)+file_ext #name of .dat file to read
				lats, longs, av, metadata = self.read_fcst_switch(fname, MOS, fcst_type='probabilistic', ctlfname=ctlfname) #read the data
				for kl in range(av.shape[0]):
					list_probabilistic_by_season[j][kl].append(av[kl]) #put each part of the data from the file into its proper place- above normal, below normal, and normal for each     av.shape is kind of complicate look at read_forecast it helps

		ng_probfcst_by_season = []
		pbn, pn, pan = [],[],[]
		for j in range(self.nsea): # for each season
			p_bn_array = np.asarray(list_probabilistic_by_season[j][0]) #load below normal array
			p_n_array = np.asarray(list_probabilistic_by_season[j][1]) # load normal array
			p_an_array = np.asarray(list_probabilistic_by_season[j][2]) # load above normal array

			p_bn = np.nanmean(p_bn_array, axis=0) #average over the models
			p_n = np.nanmean(p_n_array, axis=0)   #some areas are NaN
			p_an = np.nanmean(p_an_array, axis=0) #if they are Nan for All, mark

			all_nan = np.zeros(p_bn.shape)
			for ii in range(p_bn.shape[0]): #loop over x values
				for jj in range(p_bn.shape[1]): #loop over y values (maybe not actually y, just ndx 2)
					if np.isnan(p_bn[ii,jj]) and np.isnan(p_n[ii,jj]) and np.isnan(p_an[ii,jj]): # if data is missing in all arrays, mark as missing
						all_nan[ii,jj] = 1
			missing = np.where(all_nan > 0) # set missing value flags

			max_ndxs = np.argmax(np.asarray([p_bn, p_n, p_an]), axis=0) #find index of which array is max for each (x, y) coordinate
			p_bn[np.where(max_ndxs!= 0)] = np.nan #set data = nan in below normal array where below normal probability wasnt the max out of it, normal and above normal
			p_n[np.where(max_ndxs!= 1)] = np.nan #set data = nan in normal normal array where  normal probability wasnt the max out of it, below normal and above normal
			p_an[np.where(max_ndxs!= 2)] = np.nan #set data = nan in above normal array where above normal probability wasnt the max out of it, normal and below normal
			pbn.append(p_bn)  #add prepared below normal array to list for this season
			pn.append(p_n) #add prepared  normal array to list for this season
			pan.append(p_an) #add prepared above normal array to list for this season


		if self.nsea == 1: #this is to make sure that ax[i][j] will refer to the ith model and jth season
			ax = [ax] #this is to make sure that ax[i][j] will refer to the ith model and jth season
		ax = [ax] #this is to make sure that ax[i][j] will refer to the ith model and jth season

		for i in range(1): # for each model, but this is always one because were only doing one model
			for j in range(self.nsea): #for each season
				ax[i][j].set_extent([obs_args[j].domain.wlo+x_offset,obs_args[j].domain.wlo+metadata.X*metadata.dx+x_offset,obs_args[j].domain.sla+y_offset,obs_args[j].domain.sla+metadata.Y*metadata.dy+y_offset], ccrs.PlateCarree()) #sets the lat/long boundaries of the plot area
				ax[i][j].add_feature(feature.LAND) #adds predefined cartopy land feature - gets overwritten
				pl=ax[i][j].gridlines(crs=ccrs.PlateCarree(), draw_labels=True, linewidth=1, color='gray', alpha=0.5, linestyle=(0,(2,4))) #adds dotted gridlines to plot
				pl.xlabels_top, pl.ylabels_left, pl.ylabels_right, pl.xlabels_bottom  = False, True, False, True #adds labels to dashed gridlines on left and bottom
				pl.xformatter, pl.yformatter = LONGITUDE_FORMATTER, LATITUDE_FORMATTER #sets formatters - arcane cartopy stuff

				if self.use_default == 'True': #if user wants to use default map
					ax[i][j].add_feature(self.states_provinces, edgecolor='black') #adds the cartopy default map to the plot
				if self.use_custom == "True": #if user wants to use custom shp file
					ax[i][j].add_feature(self.shape_feature) #adds custom shape file to plot
				if j == 0: # if this is the leftmost plot
					ax[i][j].text(-0.25, 0.5, "Probabilistic Forecast (Dominant Tercile)",rotation='vertical', verticalalignment='center', horizontalalignment='center', transform=ax[i][j].transAxes) #print title vertially on the left side
				if i == 0: # if this is the top plot
					ax[i][j].set_title(obs_args[j].target_season.tgt) #print season on top of each plot

				CS1 = ax[i][j].pcolormesh(np.linspace(longs[0], longs[-1],num=len(longs)), np.linspace(lats[0], lats[-1], num=len(lats)), pbn[j], vmin=35, vmax=80,cmap=current_cmap_copper) #adds probability of below normal where below normal is most likely  and nan everywhere else
				CS2 = ax[i][j].pcolormesh(np.linspace(longs[0], longs[-1],num=len(longs)), np.linspace(lats[0], lats[-1], num=len(lats)), pn[j], vmin=35, vmax=55,cmap=current_cmap_binary) # adds probabilty of normal where normal is most likely and nan elsewhere ( doesnt overwrite below normal )
				CS3 = ax[i][j].pcolormesh(np.linspace(longs[0], longs[-1],num=len(longs)), np.linspace(lats[0], lats[-1], num=len(lats)), pan[j], vmin=35, vmax=80,cmap=current_cmap_ylgn) # adds probability of above normall where its most likely compared to normal / bn  (still wont over write )

				bounds = [40,45,50,55,60,65,70,75] #defines ticks on the colormaps
				nbounds = [40,45,50] #also for colormaps ticks

				axins_f_bottom = inset_axes(ax[i][j], width="40%",height="5%",    loc='lower left',bbox_to_anchor=(-0.2, -0.15, 1.2, 1),bbox_transform=ax[i][j].transAxes,borderpad=0.1 ) #describe where and how the colorbar for bn goes
				axins2_bottom = inset_axes(ax[i][j],  width="20%",  height="5%",  loc='lower center',bbox_to_anchor=(-0.0, -0.15, 1, 1),bbox_transform=ax[i][j].transAxes,borderpad=0.1 ) #describe where and how the colorbar for n goes
				axins3_bottom = inset_axes(ax[i][j],width="40%",  height="5%", loc='lower right', bbox_to_anchor=(0, -0.15, 1.2, 1), bbox_transform=ax[i][j].transAxes, borderpad=0.1 ) #describe where and how the colorbar for an goes

				cbar_fbl = fig.colorbar(CS1, ax=ax[i][j], cax=axins_f_bottom, orientation='horizontal', ticks=bounds) #adds bn colorbar
				cbar_fbl.set_label('BN Probability (%)') # adds label below bn colorbar
				cbar_fbc = fig.colorbar(CS2, ax=ax[i][j],  cax=axins2_bottom, orientation='horizontal', ticks=nbounds) #adds n colorbar
				cbar_fbc.set_label('N Probability (%)') # adds label below n colorbar
				cbar_fbr = fig.colorbar(CS3, ax=ax[i][j],  cax=axins3_bottom, orientation='horizontal', ticks=bounds) #adds an colorbar
				cbar_fbr.set_label('AN Probability (%)') # adds label below an colorbar


		filename =  '{}_ProbabilisticForecast_RT'.format(model) # where to save plot
		fig.savefig('./images/' + filename + '.png', dpi=500, bbox_inches='tight') #saves the plot
		if self.verbose: # if we ant to show plot, show plot if not the n dont
			plt.show()
		else:
			plt.close()

	def plt_deterministic(self, model, obs_args, MOS, shp_file="False", map_color=None, use_custom=None, use_default=None, use_topo="False"):
		use_custom = self.use_custom if use_custom is None else use_custom # allow user to override  use_custom for this funciton
		use_default = self.use_default if use_default is None else use_default # allow user to override  use_default for this funciton
		if use_custom: #if user wants to use their own shp file
			shp_file = self.shp_file if shp_file=="False" else shp_file # allow user to override  use_shpfiel for this funciton
		map_color = self.map_color if map_color is None else map_color # allow user to override  mapcolor for this funciton
		if not self.validate_args(shp_file, map_color, use_topo, use_default, models=[model], args=obs_args, MOS='None'): # if args are messed up , quit
			print('Invalid pltmap parameters- fix them!')
			return -999
		self.shp_file, self.map_color = shp_file, map_color # allow user to override plot settings
		self.use_topo = str(self.use_topo)  # allow user to override plot setting
		self.use_default = str(self.use_default)  # allow user to override plot setting
		if str(use_custom) == "True":
			self.shape_feature = ShapelyFeature(Reader(self.shp_file).geometries(), ccrs.PlateCarree(), facecolor='none')
		x_offset = 0.6 if obs_args[0].obs == 'ENACTS-BD' else 0 #fix enacts BD plotting
		y_offset = 0.4 if obs_args[0].obs == 'ENACTS-BD' else 0 #fix enacts BD plotting
		self.nsea = len(obs_args) #self.nmods is set in self.set_models - for this its always 1: 'NextGen' is passed as the model

		current_cmap = plt.get_cmap('BrBG') #set colormap
		current_cmap.set_bad('white',0.0) #set colormap
		current_cmap.set_under('white', 0.0) #set colormap

		fig, ax = plt.subplots(nrows=1, ncols=self.nsea, figsize=(13*self.nsea, 10),sharex=True,sharey=True, subplot_kw={'projection': ccrs.PlateCarree()}) #create nseas x 1 grid of map figures to plot on

		file_ext = '.dat' if platform.system() == "Windows" else ".txt" #read binary file if on windows
		list_det_by_season = [[] for i in range(self.nsea)] #arrays to fill
		for i in range(1): #for each model (but always one )
			for j in range(self.nsea): #for each season
				ctlfname = "output/" + model + '_' + obs_args[j].predictand + obs_args[j].predictand +'_' + '{}' + 'FCST_mu_' + obs_args[j].target_season.tgt + '_' +obs_args[j].target_season.init+str(obs_args[j].domain.fyr)+file_ext #name of ctl file to get metadata from - file_ext is overwritten later
				fname = "output/" + model + '_' + obs_args[j].predictand  +'_' + '{}' + 'FCST_mu_' + obs_args[j].target_season.tgt + '_' +obs_args[j].target_season.init+str(obs_args[j].domain.fyr)+file_ext #name of data file to read - file_ext is either .txt or .dat
				lats, longs, av, metadata = self.read_fcst_switch(fname, MOS, fcst_type='deterministic', ctlfname=ctlfname) #reads data and metadata
				list_det_by_season[j].append(av[0]) #theres only one array for deterministic forecast files-  just one number, its prcp - mm

		ng_detfcst_by_season = [] #arrays to fill
		for j in range(self.nsea):
			d_array = np.asarray(list_det_by_season[j]) #averaging over all models - think unnecessary but leave it for now
			d_nanmean = np.nanmean(d_array, axis=0)
			ng_detfcst_by_season.append(d_nanmean)

		if self.nsea == 1: #make sure ax[i][j] gets ith model and jth season in plotting figure grid
			ax = [ax]
		ax = [ax]

		for i in range(1): #again, for each model but only one model for this funcion
			for j in range(self.nsea): #for each season
				ax[i][j].set_extent([obs_args[j].domain.wlo+x_offset,obs_args[j].domain.wlo+metadata.X*metadata.dx+x_offset,obs_args[j].domain.sla+y_offset,obs_args[j].domain.sla+metadata.Y*metadata.dy+y_offset], ccrs.PlateCarree()) #set lat / long bounds of each plot
				ax[i][j].add_feature(feature.LAND) #add land image to plot - gets overwritten i think
				pl=ax[i][j].gridlines(crs=ccrs.PlateCarree(), draw_labels=True, linewidth=1, color='gray', alpha=0.5, linestyle=(0,(2,4))) #add gridlines to plot
				pl.xlabels_top, pl.ylabels_left, pl.ylabels_right, pl.xlabels_bottom  = False, True, False, True #add gridline labels one left and bottom of plot
				pl.xformatter, pl.yformatter = LONGITUDE_FORMATTER, LATITUDE_FORMATTER #arcane cartopy stuff but dont mess with it

				if self.use_default == 'True': #if user wants to use cartopy maps:
					ax[i][j].add_feature(self.states_provinces, edgecolor='black') #add cartopy maps
				if self.use_custom == "True": #if user wants to use tehir own map
					ax[i][j].add_feature(self.shape_feature) #add custom shape file
				if j == 0: #if this is the leftmost plot in the grid, write label vertially on the left
					ax[i][j].text(-0.25, 0.5, "Deterministic Forecast",rotation='vertical', verticalalignment='center', horizontalalignment='center', transform=ax[i][j].transAxes)
				if i == 0: # it this is the top row of the grid: set season as title
					ax[i][j].set_title(obs_args[j].target_season.tgt)

				axins = inset_axes(ax[i][j], width="5%", height="100%",  loc='center right', bbox_to_anchor=(0., 0., 1.15, 1), bbox_transform=ax[i][j].transAxes, borderpad=0.1,) #describes where colorbar should go
				var = ng_detfcst_by_season[j] #plotting firecast for this season
				CS_det = ax[i][j].pcolormesh(np.linspace(longs[0], longs[-1],num=len(longs)), np.linspace(lats[0], lats[-1], num=len(lats)), var, norm=MidpointNormalize(midpoint=0.), cmap=current_cmap) #add forecast data to map
				cbar_bdet = fig.colorbar(CS_det, ax=ax[i][j],  cax=axins, orientation='vertical', pad = 0.02) #add colorbar based on forecast data
				cbar_bdet.set_label('Rainfall (mm)')# add colorbar label
		filename =  '{}_DeterministicForecast_RT'.format(model) #where to savve file
		fig.savefig('./images/' + filename + '.png', dpi=500, bbox_inches='tight') #save file
		if self.verbose:
			plt.show() #if we want to show the plot, show it .
		else:
			plt.close()

	def pltdomain(self, obs_args, hindcast_args, use_custom=None, use_default=None):
		"""allow user to exxamine predictor and predictand domains for the statistical model theyre building"""
		use_custom = self.use_custom if use_custom is None else use_custom #allow user to override shpe file
		use_default = self.use_default if use_default is None else use_default #allow user to turn on / off default maps

		fig = plt.subplots(figsize=(15,15), subplot_kw=dict(projection=ccrs.PlateCarree())) #create plotting grid with maps

		ax = plt.subplot(1, 2, 1, projection=ccrs.PlateCarree()) #select first of a 1x2 plot grid
		ax.set_extent([hindcast_args.domain.wlo,hindcast_args.domain.elo,hindcast_args.domain.nla,hindcast_args.domain.sla], ccrs.PlateCarree()) #set lat /lon bounds
		pl=ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True, linewidth=1, color='gray', alpha=0.5, linestyle=(0,(2,4))) #add dashed gray gridlines
		pl.xlabels_top, pl.ylabels_left = False, False #turn off labels for top and left for gridlines
		pl.xformatter, pl.yformatter = LONGITUDE_FORMATTER, LATITUDE_FORMATTER #add formatters , arcane cartopy stuff
		if str(use_custom) == "True":
			self.shape_feature = ShapelyFeature(Reader(self.shp_file).geometries(), ccrs.PlateCarree(), facecolor='none')

		ax.add_feature(feature.LAND) #adds gray land imagerhy
		ax.add_feature(feature.OCEAN) #adds blue water imagery
		if self.use_topo == "True": #if users selected to use topography pixelated image
			ax.stock_img() #adds topography image
		if use_default == "True": #if user has not overridden default shaep file
			ax.add_feature(self.states_provinces, edgecolor='black') # add default map boundaries to plot
		if use_custom == "True": #if user wants to use a custom shape file
			ax.add_feature(self.shape_feature, edgecolor='black') #add their shapep file
		ax.set_title('Predictor') #sets plot title

		ax = plt.subplot(1, 2, 2, projection=ccrs.PlateCarree()) #select second of a 1x2 plot grid
		ax.set_extent([obs_args.domain.wlo,obs_args.domain.elo,obs_args.domain.nla,obs_args.domain.sla], ccrs.PlateCarree()) #set lat /lon bounds
		pl=ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True, linewidth=1, color='gray', alpha=0.5, linestyle=(0,(2,4))) #add dashed gray gridlines
		pl.xlabels_top, pl.ylabels_left = False, False #turn off labels for top and left for gridlines
		pl.xformatter, pl.yformatter = LONGITUDE_FORMATTER, LATITUDE_FORMATTER #add formatters , arcane cartopy stuff
		ax.add_feature(feature.LAND) #adds gray land imagerhy
		ax.add_feature(feature.OCEAN) #adds blue water imagery
		if self.use_topo == "True": #if users selected to use topography pixelated image
			ax.stock_img() #adds topography image
		if use_default == "True": #if user has not overridden default shaep file
			ax.add_feature(self.states_provinces, edgecolor='black') # add default map boundaries to plot
		if use_custom == "True": #if user wants to use a custom shape file
			ax.add_feature(self.shape_feature, edgecolor='black') #add their shapep file
		ax.set_title('Predictand') #sets plot title

		plt.savefig("./images/domain.png",dpi=300, bbox_inches='tight') #SAVE_FILE 0_domain.png
		if self.verbose:
			plt.show() #show file if desired, else close to prevent it
		else:
			plt.close()

	def validate_args(self, shp_file, map_color, use_topo, use_default, models=[], args=[], MOS=None):
		"""validates args - tgts and inits are validated in Domain and TargetSeason
			models and args are optional and only used to validate that CPT has been run for all models"""
		retval = True
		if map_color not in ['CPT', 'Angel', 'viridis', 'plasma', 'inferno', 'magma', 'cividis', 'Greys', 'Purples', 'Blues', 'Greens', 'Oranges', 'Reds', 'YlOrBr', 'YlOrRd', 'OrRd', 'PuRd', 'RdPu', 'BuPu', 'GnBu', 'PuBu', 'YlGnBu', 'PuBuGn', 'BuGn', 'YlGn', 'binary', 'gist_yarg', 'gist_gray', 'gray', 'bone', 'pink', 'spring', 'summer', 'autumn', 'winter', 'cool', 'Wistia', 'hot', 'afmhot', 'gist_heat', 'copper', 'PiYG', 'PRGn', 'BrBG', 'PuOr', 'RdGy', 'RdBu', 'RdYlBu', 'RdYlGn', 'Spectral','coolwarm', 'bwr', 'seismic','twilight', 'twilight_shifted', 'hsv', 'Pastel1', 'Pastel2', 'Paired', 'Accent','Dark2', 'Set1', 'Set2', 'Set3','tab10', 'tab20', 'tab20b', 'tab20c', 'flag', 'prism', 'ocean', 'gist_earth', 'terrain', 'gist_stern','gnuplot', 'gnuplot2', 'CMRmap', 'cubehelix', 'brg','gist_rainbow', 'rainbow', 'jet', 'nipy_spectral', 'gist_ncar']:
			print('map_color must be one of "CPT", "Angel", or a pyplot colormap')
			retval = retval and False

		if MOS is not None:
			if MOS not in ['CCA', 'PCR', 'ELR', 'None']:
				print('Invalid MOS - {}'.format(MOS))
				retval = retval and False

		valid_models = ['NextGen', 'CMC1-CanCM3', 'CMC2-CanCM4', 'CanSIPSv2', 'COLA-RSMAS-CCSM4', 'GFDL-CM2p5-FLOR-A06', 'GFDL-CM2p5-FLOR-B01','GFDL-CM2p1-aer04', 'NASA-GEOSS2S', 'NCEP-CFSv2']
		for arg in args: #validate all seasons
			for model in models: #validate all models
				if model not in valid_models: #check if valid model
					if self.verbose:
						print('{} Not a valid model'.format(model))
					retval = retval and False
				check, fullpath = self.fm.check("./output/{}_{}{}_{}_2AFC_{}_{}.ctl".format(model, arg.predictor, arg.predictand, self.MOSs[MOS], arg.target_season.tgt, arg.target_season.init)) #look for COLAblahblah_PRCPPRCP_CCA_2AFC_Jun-Sep-May.ctl
				if not check:
					print("Looks like CPT wasn't successfully run for {} - {}".format(model, fullpath))
					retval = retval and False


		if not os.path.isfile(shp_file):
			if self.verbose:
				print('Invalid ShapeFile - using default')
			self.use_default, self.use_custom = True, False
		else:
			try:
				self.shape_feature = ShapelyFeature(Reader(shp_file).geometries(), ccrs.PlateCarree(), facecolor='none')
			except:
				print('Unable to load ShapeFile - using default')
				self.use_default, self.use_custom =True, False


		if use_topo not in ['True', 'False']:
			print('use_topo must be a string, in ["True", "False"]')
			retval=retval and False

		if str(use_default) not in ['True', 'False']:
			print('use_default must be a string, in ["True", "Fasle"]')
			print('Using default shp_files')
			self.use_default = True

		return retval

	def make_cmap(self, N):
		if self.map_color == 'CPT':
			colors = [(238, 43, 51), (255, 57, 67),(253, 123, 91),(248, 175, 123),(254, 214, 158),(252, 239, 188),(255, 254, 241),(244, 255,255),(187, 252, 255),(160, 235, 255),(123, 210, 255),(89, 179, 238),(63, 136, 254),(52, 86, 254)]
			colors = [ (colors[i][0] / 255.0, colors[i][1] / 255.0, colors[i][2] / 255.0) for i in range(len(colors))]
			colors.reverse()
			return LinearSegmentedColormap.from_list( "CPT", colors, N=N)
		else:
			self.map_color = 'bwr' if self.map_color == 'Angel' else self.map_color
			return plt.get_cmap(self.map_color, N)

	def plteofs(self, models, MOS, eofmodes, cur_mode, obs_args, map_color=None, use_custom=None):
		"""Everything should be validated by now, so no need to look"""
		use_custom = self.use_custom if use_custom is None else use_custom
		self.map_color = self.map_color if map_color is None else map_color #allow user to override map color for htis function
		current_cmap = self.make_cmap(14) #make the custom color map , not strictly necessary unless you want the custom ones because if you request pyplot..cmap it just gives you that

		if MOS=='None':
			print('No EOFs are computed if MOS=None is used') #exit if we havent computer EOFs during CPT
			return
		if self.verbose:
			print('\n\n\n-------------EOF {}-------------\n'.format(cur_mode+1))

		self.set_models(models) #sets internal nmods and models list variables
		self.nsea = len(obs_args) #obs_args holds an ArgSet for each season which couples domains with the target seasons objects
		self.nmods = self.nmods + 1 if MOS =='CCA' else self.nmods #for MOS=CCA, we plot the EOFS of the observations 'which are stored in the EOFY file at the top of the grid

		if str(use_custom) == "True":
			self.shape_feature = ShapelyFeature(Reader(self.shp_file).geometries(), ccrs.PlateCarree(), facecolor='none')
		fig, ax = plt.subplots(nrows=self.nmods, ncols=self.nsea, sharex=False,sharey=False, figsize=(10*self.nsea,6*self.nmods), subplot_kw={'projection': ccrs.PlateCarree()}) #create grid of plots with maps
		if self.nsea==1 and self.nmods == 1: ## this if/else makes sure ax[i][j] refers to the (ith, jth) image in the plotting grid
			ax = [[ax]]
		elif self.nsea == 1:
			ax = [[ax[q]] for q in range(self.nmods)]
		elif self.nmods == 1:
			ax = [ax]


		for i in range(self.nmods): #for each model, + 1 for observations if CCA
			for j in range(self.nsea): #for each  target season for that model
				label = 'EOF Charges' # label is the same for all
				if i == 0 and MOS=='CCA':
					ctl_file = 'output/{}_{}{}_{}_{}_{}_{}.ctl'.format(self.models[i], obs_args[j].predictor, obs_args[j].predictand, self.MOSs[MOS], 'EOFY', obs_args[j].target_season.tgt, obs_args[j].target_season.init) #name of EOFY .ctl file to get metadata from
					eofy_meta = self.fm.read_ctl(ctl_file) #reads metadata, returns a MetaTensor object
					eofy = self.fm.read_eof_dat(eofmodes, self.models[i], obs_args[j], 'EOFY', MOS, eofy_meta) #uses the metatensor object we just got to read the EOFY data
					ax[i][j].set_extent([eofy_meta.wlo, eofy_meta.elo, eofy_meta.sla, eofy_meta.nla], crs=ccrs.PlateCarree()) #set lat/long boundaries of plot using the metadata's spatial limits
					CS=ax[i][j].pcolormesh(np.linspace(eofy_meta.elo, eofy_meta.wlo,num=eofy_meta.X+1), np.linspace(eofy_meta.nla, eofy_meta.sla, num=eofy_meta.Y+1), eofy[cur_mode,:,:], vmin=-.1,vmax=.1, cmap=current_cmap, transform=ccrs.PlateCarree()) #adds the EOFY data to the plot
					if j == 0: #if this is the leftmost plot in the grid
						ax[i][j].text(-0.42, 0.5, 'Obs',rotation='vertical', verticalalignment='center', horizontalalignment='center', transform=ax[i][j].transAxes) #label row as obs - since this is for if i=0 and MOS is CCA
				elif MOS=='CCA' and i > 0: #else, if MOS is CCA and i > 0 we are plotting an input predictor model's EOFs so EOFX file
					ctl_file = 'output/{}_{}{}_{}_{}_{}_{}.ctl'.format(self.models[i-1], obs_args[j].predictor, obs_args[j].predictand, self.MOSs[MOS], 'EOFX', obs_args[j].target_season.tgt, obs_args[j].target_season.init) #name of file to get metadta for model's EOFX output file
					eofx_meta = self.fm.read_ctl(ctl_file) #read EOFX metadta
					eofx = self.fm.read_eof_dat(eofmodes, self.models[i-1], obs_args[j], 'EOFX', MOS, eofx_meta) #read binary EOF file using metadata we jsut got
					ax[i][j].set_extent([eofx_meta.wlo, eofx_meta.elo, eofx_meta.sla, eofx_meta.nla], crs=ccrs.PlateCarree()) #set spatial extent of plot
					CS=ax[i][j].pcolormesh(np.linspace(eofx_meta.elo, eofx_meta.wlo,num=eofx_meta.X+1), np.linspace(eofx_meta.nla, eofx_meta.sla, num=eofx_meta.Y+1), eofx[cur_mode,:,:], vmin=-.1,vmax=.1, cmap=current_cmap, transform=ccrs.PlateCarree()) #add eofX data according to lats/longs
					if j == 0: #since this is for a model's EOF, if thsi is leftmost plot, label on leftside of model name
						ax[i][j].text(-0.42, 0.5, self.models[i-1],rotation='vertical', verticalalignment='center', horizontalalignment='center', transform=ax[i][j].transAxes)
				else: #if we're not using CCA, (ELR or PCR), then  no need to plot predictand EOFs
					ctl_file = 'output/{}_{}{}_{}_{}_{}_{}.ctl'.format(self.models[i], obs_args[j].predictor, obs_args[j].predictand, self.MOSs[MOS], 'EOFX', obs_args[j].target_season.tgt, obs_args[j].target_season.init) #name of PCR or ELR EOF metadata file
					eofx_meta = self.fm.read_ctl(ctl_file) #get metadata
					eofx = self.fm.read_eof_dat(eofmodes, self.models[i], obs_args[j], 'EOFX', MOS, eofx_meta) #use metadata to read EOFX binary file
					ax[i][j].set_extent([eofx_meta.wlo, eofx_meta.elo, eofx_meta.sla, eofx_meta.nla], crs=ccrs.PlateCarree()) #set spatial limits of EOFX plot
					CS=ax[i][j].pcolormesh(np.linspace(eofx_meta.elo, eofx_meta.wlo,num=eofx_meta.X+1), np.linspace(eofx_meta.nla, eofx_meta.sla, num=eofx_meta.Y+1), eofx[cur_mode,:,:], vmin=-.1,vmax=.1, cmap=current_cmap, transform=ccrs.PlateCarree()) #add eofX data to plot
					if j == 0: #if this is the leftmost, add model name as lebel on left side
						ax[i][j].text(-0.42, 0.5, self.models[i],rotation='vertical', verticalalignment='center', horizontalalignment='center', transform=ax[i][j].transAxes)

				if i == 0:# if this is the top row
					ax[i][j].set_title(obs_args[j].target_season.tgt) #add column title of target season 'Jun-Sep' eg
				ax[i][j].add_feature(feature.LAND) #adds gray land image to plot, gets overwritten  by data
				pl=ax[i][j].gridlines(crs=ccrs.PlateCarree(), draw_labels=True, linewidth=1, color='gray', alpha=0.5, linestyle=(0,(2,4))) #adds dashed gray gridlines to plot
				pl.xlabels_top, pl.ylabels_left, pl.ylabels_right, pl.xlabels_bottom  = False, True, False, True #set lat/long labels for gridlines on left and bottom sides
				pl.xformatter, pl.yformatter = LONGITUDE_FORMATTER, LATITUDE_FORMATTER #arcane cartopy stuff- just dont delet this lol

				if self.use_default == 'True': #if we are using the default cartopy map
					ax[i][j].add_feature(self.states_provinces, edgecolor='black') #add the map
				if self.use_custom == "True": #if we are using a custom map
					ax[i][j].add_feature(self.shape_feature) #add the map
				axins = inset_axes(ax[i][j], width="5%",  height="100%", loc='center right', bbox_to_anchor=(0., 0., 1.15, 1), bbox_transform=ax[i][j].transAxes, borderpad=0.1) #describes location and style of colorbar
				cbar = plt.colorbar(CS,ax=ax[i][j], cax=axins, orientation='vertical', pad=0.01, ticks= [-0.09, -0.075, -0.06, -0.045, -0.03, -0.015, 0, 0.015, 0.03, 0.045, 0.06, 0.075, 0.09]) #adds colorbar
				cbar.set_label(label) #sets label for colorbar

		#save file
		if self.models[0] == 'NextGen':
			fig.savefig('./images/EOF{}_NextGen.png'.format(cur_mode+1, dpi=500, bbox_inches='tight'))
		else:
			fig.savefig('./images/EOF{}_Models.png'.format(cur_mode+1, dpi=500, bbox_inches='tight'))

		#show plot if we want that right now
		if self.verbose:
			plt.show()
		else:
			plt.close()

	def pltmap(self, met, models,  obs_args, MOS, shp_file="False", map_color=None, use_custom=None, use_default=None,ng=[], use_topo="False"):
		use_custom = self.use_custom if use_custom is None else use_custom #allow user to add custom map
		use_default = self.use_default if use_default is None else use_default #allow user  to turn off default map
		if use_custom: #if were using a custom map
			shp_file = self.shp_file if shp_file=="False" else shp_file #load the custom map
		map_color = self.map_color if map_color is None else map_color
		if not self.validate_args(shp_file, map_color, use_topo, use_default, models=models, args=obs_args, MOS=MOS): #if the args are all okay
			print('Invalid pltmap parameters- fix them!')
			return -999
		self.set_models(models) # sets nmods, models variable to list of models
		self.shp_file, self.map_color = shp_file, map_color # sets these variables for later
		self.use_topo = str(self.use_topo) #must cast to string because of artefact from old code
		self.use_default = str(self.use_default) #must cast to string because it comes from old version, and im not fixing it rn
		x_offset = 0.6 if obs_args[0].obs == 'ENACTS-BD' else 0 #fix ENACTS-BD data sihfting issue
		y_offset = 0.4 if obs_args[0].obs == 'ENACTS-BD' else 0 #fix ENACTS-BD data sihfting issue
		self.nsea = len(obs_args) #self.nmods is set in self.set_models

		fig, ax = plt.subplots(nrows=self.nmods, ncols=self.nsea, figsize=(6*self.nsea, 6*self.nmods),sharex=False,sharey=False, subplot_kw={'projection': ccrs.PlateCarree()}) #create nmods x nseas grid of plots with maps

		if str(use_custom) == "True":
			self.shape_feature = ShapelyFeature(Reader(self.shp_file).geometries(), ccrs.PlateCarree(), facecolor='none')

		if self.nsea==1 and self.nmods == 1: #this if else is so ax[i][j] refers to the plot at position [model][season]
			ax = [[ax]]
		elif self.nsea == 1:
			ax = [[ax[q]] for q in range(self.nmods)]
		elif self.nmods == 1:
			ax = [ax]

		current_cmap = self.make_cmap(10) if met not in ['Pearson', 'Spearman'] else self.make_cmap(14) #make colormaps that match styles of CPT
		self.pltmap_argdict = { #this just makes it easier / more readable below- before we had a very long if/else for each one
			'2AFC':{'label': '2AFC (%)', 'setnans': True, 'vmin': 0, 'vmax': 100, 'cmap': current_cmap, 'bounds': [10*gt for gt in range(1,10, 2)]},
			'RMSE':{'label': 'RMSE', 'setnans': True, 'vmin': 0, 'vmax': 1000, 'cmap': plt.get_cmap('Reds', 10), 'bounds':[100*gt for gt in range(1,10, 2)]},
			'RocAbove': {'label': 'ROC Area', 'setnans': True, 'vmin': 0, 'vmax': 1, 'cmap': current_cmap, 'bounds':[0.1*gt for gt in range(1,10, 2)]},
			'RocBelow': {'label': 'ROC Area', 'setnans': True, 'vmin': 0, 'vmax': 1, 'cmap': current_cmap, 'bounds':[0.1*gt for gt in range(1,10, 2)]},
			'Pearson':  {'label': 'Correlation', 'setnans': True, 'vmin': -1.05, 'vmax': 1.05, 'cmap': current_cmap, 'bounds': [-0.9, -0.75, -0.6, -0.45, -0.3, -0.15, 0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9]},
			'Spearman':  {'label': 'Correlation', 'setnans': True, 'vmin': -1.05, 'vmax': 1.05, 'cmap': current_cmap, 'bounds': [-0.9, -0.75, -0.6, -0.45, -0.3, -0.15, 0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9]},
			'Ignorance': {'label': 'Ignorance', 'setnans': True, 'vmin': False, 'vmax': False, 'cmap': current_cmap, 'bounds':False},
			'RPSS': {'label': 'RPSS', 'setnans': True, 'vmin': False, 'vmax': False, 'cmap': current_cmap, 'bounds':False},
			'GROC': {'label': 'GROC', 'setnans': True, 'vmin': False, 'vmax': False, 'cmap': current_cmap, 'bounds':False},
		}

		if self.verbose:
			print('\n' + str(met)) #prints metric
		for i in range(self.nmods): #for each model
			for j in range(self.nsea): #for each target season
				ctlfile = 'output/{}_{}{}_{}_{}_{}_{}.ctl'.format(self.models[i], obs_args[j].predictand, obs_args[j].predictand, self.MOSs[MOS], met, obs_args[j].target_season.tgt, obs_args[j].target_season.init) #name of metadata file
				metadata = self.fm.read_ctl(ctlfile) #read metadata- needed to read binary output .dat file
				ax[i][j].set_extent([obs_args[j].domain.wlo+x_offset,obs_args[j].domain.wlo+metadata.X*metadata.dx+x_offset,obs_args[j].domain.sla+y_offset,obs_args[j].domain.sla+metadata.Y*metadata.dy+y_offset], ccrs.PlateCarree()) #sets lat/long limits (zoom level) of map plot
				ax[i][j].add_feature(feature.LAND) #adds gray land feature to map, data will cover it where there is data
				pl=ax[i][j].gridlines(crs=ccrs.PlateCarree(), draw_labels=True, linewidth=1, color='gray', alpha=0.5, linestyle=(0,(2,4))) #adds dashed gray gridlines to the plot
				pl.xlabels_top, pl.ylabels_left, pl.ylabels_right, pl.xlabels_bottom  = False, True, False, True #turns on lat/long labels for gridlines on left and bottom sides of plot
				pl.xformatter, pl.yformatter = LONGITUDE_FORMATTER, LATITUDE_FORMATTER #arcane cartopy code, dont delete

				if self.use_default == 'True': #if using default map
					ax[i][j].add_feature(self.states_provinces, edgecolor='black') #add default map
				if self.use_custom == "True": #if using custom map
					ax[i][j].add_feature(self.shape_feature) #add custom map
				if j == 0: #if this is leftmost plot, add model label on left side
					ax[i][j].text(-0.42, 0.5, self.models[i],rotation='vertical', verticalalignment='center', horizontalalignment='center', transform=ax[i][j].transAxes)
				if i == 0: #if this is first model, add season title to top
					ax[i][j].set_title(obs_args[j].target_season.tgt)

				var = self.fm.read_met_dat(self.models[i], obs_args[j], met, self.MOSs[MOS], metadata) #read binary .dat data about metrcis
				axins = inset_axes(ax[i][j], width="5%", height="100%",  loc='center right', bbox_to_anchor=(0., 0., 1.15, 1), bbox_transform=ax[i][j].transAxes, borderpad=0.1,) #describes location and style of colorbar

				if met in ['Ignorance', 'RPSS', 'GROC']: #for these three metrics, we let pyplot decide the bounds of the colorbar because i dont know what reasonable values might be
					var[var==-999]=np.nan #if somebody knows better reasonable values, please fix
					CS=ax[i][j].pcolormesh(np.linspace(obs_args[j].domain.wlo+x_offset, obs_args[j].domain.wlo+metadata.X*metadata.dx+x_offset,num=metadata.X+1), np.linspace(obs_args[j].domain.sla+metadata.Y*metadata.dy+y_offset, obs_args[j].domain.sla+y_offset, num=metadata.Y+1), var, cmap=current_cmap, transform=ccrs.PlateCarree()) #add metric data to plot
					cbar = fig.colorbar(CS, ax=ax[i][j], cax=axins, orientation='vertical', pad=0.02) #add colorbar to right side
				else:
					if met not in ['Pearson', 'Spearman']:
						var[var<0]=np.nan #only positive values for antyhing but correlation
					else:
						var[var<-1.]=np.nan #anything less than 1 for correlation is invalid
					CS=ax[i][j].pcolormesh(np.linspace(obs_args[j].domain.wlo+x_offset, obs_args[j].domain.wlo+metadata.X*metadata.dx+x_offset,num=metadata.X+1), np.linspace(obs_args[j].domain.sla+metadata.Y*metadata.dy+y_offset, obs_args[j].domain.sla+y_offset, num=metadata.Y+1), var, vmin=self.pltmap_argdict[met]['vmin'], vmax=self.pltmap_argdict[met]['vmax'], cmap=self.pltmap_argdict[met]['cmap'], transform=ccrs.PlateCarree()) #add metric data to plot
					cbar = fig.colorbar(CS, ax=ax[i][j], cax=axins, orientation='vertical', pad=0.02, ticks=self.pltmap_argdict[met]['bounds']) # add colorbar to plot with specified ticks, and spacing
				cbar.set_label(self.pltmap_argdict[met]['label']) #set label for each metric

		filename =  'NextGen_' + met if self.models[0] == 'NextGen' else 'Models_'+met #where to save
		fig.savefig('./images/' + filename + '.png', dpi=500, bbox_inches='tight') #save image
		if self.verbose: #if we want to,
			plt.show() #show the plot
		else:
			plt.close() #else prevent plot from showing
